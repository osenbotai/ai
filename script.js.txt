let botActive = false;
let aggression = 1;
let balance = 10000;
let peakBalance = 10000;
let todayProfit = 0;
let totalProfit = 0;
let wins = 0;
let totalTrades = 0;
let maxDrawdown = 0;
let equityData = [10000];
let tradesToday = 0;

const els = {
    balance: document.getElementById('balance'),
    todayProfit: document.getElementById('todayProfit'),
    totalProfit: document.getElementById('totalProfit'),
    winRate: document.getElementById('winRate'),
    drawdown: document.getElementById('drawdown'),
    riskExposure: document.getElementById('riskExposure'),
    botStatus: document.getElementById('botStatus'),
    healthStatus: document.getElementById('healthStatus'),
    confidence: document.getElementById('confidence'),
    alerts: document.getElementById('alerts'),
    aiStatus: document.getElementById('aiStatus'),
    marketSession: document.getElementById('marketSession'),
    tradeTable: document.getElementById('tradeTable'),
    chart: document.getElementById('equityChart').getContext('2d'),
    usersOnline: document.getElementById('usersOnline'),
    tradesTodayEl: document.getElementById('tradesToday'),
    avgRoi: document.getElementById('avgRoi')
};

// Auto Theme + Risk Popup
window.onload = () => {
    if (window.matchMedia('(prefers-color-scheme: light)').matches) {
        document.body.classList.add('light');
        document.querySelector('.theme-toggle').textContent = '‚òÄÔ∏è';
    }
    setTimeout(() => { document.getElementById('riskPopup').style.display = 'flex'; }, 1000);
    updateStats();
    drawChart();
    updateMarketSession();
    setInterval(updateMarketSession, 60000);
    setInterval(fakeUsersOnline, 8000);
    revealOnScroll();
};

// Fake live users
function fakeUsersOnline() {
    els.usersOnline.textContent = Math.floor(Math.random() * 50 + 30);
}

function toggleTheme() {
    document.body.classList.toggle('light');
    document.querySelector('.theme-toggle').textContent = document.body.classList.contains('light') ? '‚òÄÔ∏è' : 'üåô';
}

function toggleMobileMenu() {
    document.getElementById('mobileMenu').classList.toggle('active');
}

function scrollToSection(id) {
    document.getElementById(id).scrollIntoView({ behavior: 'smooth' });
    if (window.innerWidth <= 768) toggleMobileMenu();
}

function animateCounter(el, target) {
    const start = parseFloat(el.textContent.replace(/[^\d.-]/g, '')) || 0;
    const diff = target - start;
    const duration = 1800;
    let startTime = null;
    function step(ts) {
        if (!startTime) startTime = ts;
        const progress = Math.min((ts - startTime) / duration, 1);
        const current = Math.floor(start + diff * progress);
        el.textContent = '‚Çπ ' + current.toLocaleString('en-IN');
        if (progress < 1) requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
}

function updateStats() {
    animateCounter(els.balance, balance);
    animateCounter(els.todayProfit, todayProfit);
    animateCounter(els.totalProfit, totalProfit);
    els.winRate.textContent = totalTrades ? Math.round((wins / totalTrades) * 100) + '%' : '0%';
    els.riskExposure.textContent = botActive ? '0.5%' : '0%';
    els.tradesTodayEl.textContent = tradesToday;
    els.avgRoi.textContent = totalTrades ? (todayProfit / 10000 * 100).toFixed(1) + '%' : '0%';

    const dd = peakBalance > balance ? ((peakBalance - balance) / peakBalance) * 100 : 0;
    if (dd > maxDrawdown) maxDrawdown = dd;
    els.drawdown.textContent = maxDrawdown.toFixed(1) + '%';
}

function drawChart() {
    const ctx = els.chart;
    const canvas = ctx.canvas;
    ctx.canvas.width = canvas.offsetWidth;
    ctx.canvas.height = canvas.offsetHeight;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = '#00d4ff';
    ctx.lineWidth = 4;
    ctx.lineCap = 'round';
    ctx.beginPath();
    equityData.forEach((val, i) => {
        const x = (i / (equityData.length - 1)) * canvas.width;
        const y = canvas.height - (val / peakBalance * (canvas.height - 60)) + 30;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    });
    ctx.stroke();
}

window.addEventListener('resize', drawChart);

function showAlert(text, type = 'trade') {
    const alertEl = document.createElement('div');
    alertEl.className = 'alert';
    alertEl.style.background = type === 'liquidity' ? '#00d4ff' : type === 'win' ? '#00ff9d' : '#ff6b6b';
    alertEl.style.color = '#000';
    alertEl.textContent = text;
    els.alerts.appendChild(alertEl);
    setTimeout(() => alertEl.remove(), 5000);
    const beep = new Audio('data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=');
    beep.play().catch(() => {});
}

function updateMarketSession() {
    const hour = new Date().getUTCHours();
    let session = 'Asia';
    if (hour >= 8 && hour < 16) session = 'London';
    else if (hour >= 13 && hour < 21) session = 'New York';
    els.marketSession.textContent = `Market Session: ${session}`;
}

function addTrade() {
    if (!botActive) return;

    const volatility = aggression * (0.7 + Math.random() * 0.6);
    const isWin = Math.random() > (aggression > 1 ? 0.3 : 0.22);
    const profit = isWin ? (300 + Math.random() * 800) * volatility : -(80 + Math.random() * 350);

    const reasons = ['Liquidity Grab', 'SMC FVG', 'ICT Order Block', 'High AI Confidence'];
    const reason = reasons[Math.floor(Math.random() * reasons.length)];

    balance += profit;
    todayProfit += profit;
    totalProfit += profit;
    if (balance > peakBalance) peakBalance = balance;
    equityData.push(balance);
    if (isWin) wins++;
    totalTrades++;
    tradesToday++;

    showAlert(isWin ? 'üöÄ Trade Executed - Profit Locked!' : 'üõ°Ô∏è Risk Management - Trade Closed', isWin ? 'win' : 'trade');
    if (Math.random() > 0.5) showAlert('üåä Liquidity Pool Detected!', 'liquidity');

    const time = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
    const row = document.createElement('tr');
    row.className = isWin ? 'positive' : 'negative';
    row.innerHTML = `<td>${time}</td><td>XAUUSD</td><td>${isWin ? 'BUY' : 'SELL'}</td><td>20${Math.floor(40+Math.random()*80)}.${Math.floor(Math.random()*99)}</td><td>‚Çπ ${profit.toFixed(2)}</td><td>${reason}</td>`;
    els.tradeTable.prepend(row);
    if (els.tradeTable.children.length > 15) els.tradeTable.lastChild.remove();

    els.confidence.textContent = Math.floor(70 + Math.random() * 25) + '%';
    els.healthStatus.textContent = (totalTrades - wins) > wins * 1.3 ? 'Warning' : 'Stable';
    els.healthStatus.className = (totalTrades - wins) > wins * 1.3 ? 'health-warning' : 'health-stable';

    updateStats();
    drawChart();

    const delay = 8000 + Math.random() * 15000;
    setTimeout(addTrade, delay);
}

function toggleBot() {
    botActive = !botActive;
    els.botStatus.textContent = botActive ? 'ON' : 'OFF';
    els.botStatus.className = botActive ? 'status-on' : 'status-off';
    els.toggleBtn.textContent = botActive ? 'Turn OFF Bot' : 'Turn ON Bot';
    if (botActive) addTrade();
}

function resetDemo() {
    if (confirm('Reset entire demo simulation?')) location.reload();
}

document.getElementById('tradingMode').addEventListener('change', (e) => {
    const val = e.target.value;
    aggression = val === 'aggressive' ? 1.7 : val === 'safe' ? 0.6 : 1;
});

const aiTexts = ['AI Analyzing Market...', 'Scanning Liquidity Pools...', 'Detecting ICT Patterns...', 'Calculating Optimal Entry...'];
let aiIdx = 0;
setInterval(() => {
    els.aiStatus.textContent = aiTexts[aiIdx];
    aiIdx = (aiIdx + 1) % aiTexts.length;
}, 3500);

// Reveal on scroll
function revealOnScroll() {
    const reveals = document.querySelectorAll('.reveal');
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                entry.target.classList.add('active');
                observer.unobserve(entry.target);
            }
        });
    }, { threshold: 0.15 });
    reveals.forEach(el => observer.observe(el));
}